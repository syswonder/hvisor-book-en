### 4.6.1.2 Implementation of RISC-V IOMMU Standard

#### RISC-V IOMMU Workflow

For virtualized systems with DMA devices, there is a possibility that the system's stability could be compromised due to malicious DMA configurations by virtual machines. The introduction of IOMMU can further enhance the isolation between Zones, ensuring the system's security.

IOMMU supports two-stage address translation, providing DMA remapping functionality. On one hand, it offers memory protection for DMA operations, limiting the physical memory areas that devices can access, making DMA operations safer. On the other hand, device DMA operations only require continuous IOVA, not continuous PA, allowing efficient use of scattered pages in physical memory.

To perform address translation and memory protection, RISC-V IOMMU uses the same page table format as the CPU's MMU in both the first and second stages. Using the same page table format as the CPU MMU simplifies some complexities in memory management for DMA and allows the CPU MMU and IOMMU to use the same page tables.

The second-stage address translation process supported in hvisor, i.e., the translation from device-side IOVA (GPA) to HPA, is shown in the following diagrams, and the second-stage page tables are shared between the CPU MMU and IOMMU:

IOMMU needs to first locate the device context (DC) in the device directory table using the device identifier (device_id) before translation. Each device has a unique device_id, which is specified during hardware implementation for platform devices, and for PCI/PCIe devices, the BDF number of the PCI/PCIe device is used as the device_id. The DC contains information such as the base address of the two-stage address translation page tables and some translation control information. For example, in two-stage address translation, the I/O device's IOVA is first translated into GPA in the Stage-1 page table pointed to by the fsc field, then into HPA in the Stage-2 page table pointed to by the iohgatp field, and then accesses memory accordingly. In hvisor, only the second-stage translation using the iohgatp field is supported, as shown below:

RISC-V IOMMU, as a physical hardware, can be accessed via MMIO, and its various fields' byte offsets are specified in the IOMMU specification manual. Implementation needs to access these fields correctly according to the specified offsets and sizes. The IommuHw structure is defined to simplify access to the physical IOMMU, as shown below:

The Capabilities of the IOMMU is a read-only register that reports the supported functions of the IOMMU. When initializing the IOMMU, it is necessary to first check this register to determine if the hardware supports IOMMU functions.

During initialization, the IOMMU must first check if the current IOMMU matches the driver. The rv_iommu_check_features function is defined to check for hardware support for features like Sv39x4, WSI, etc., as shown below:

The fctl of the IOMMU is a functional control register, providing some functional controls of the IOMMU, including whether the IOMMU accesses memory data in big-endian or little-endian, whether the interrupts generated by the IOMMU are WSI or MSI interrupts, and controls for the Guest address translation scheme.

The ddtp of the IOMMU is a device directory table pointer register, which contains the root page's PPN of the device directory table and the IOMMU Mode. It can be configured to Off, Bare, 1LVL, 2LVL, or 3LVL, where Off means the IOMMU does not allow device access to memory, Bare means the IOMMU allows all memory access by devices without translation and protection, and 1LVL, 2LVL, 3LVL indicate the number of levels in the device directory table used by the IOMMU.

The rv_iommu_init function is defined for checking and controlling the functions of the physical IOMMU, such as configuring interrupts as WSI, configuring the device directory table, etc., as shown below:

The entry format of the device directory table is provided in the specification manual. To make the hardware work, it needs to be implemented in conjunction with the specification. The DdtEntry structure is defined to represent an entry in the device directory table, representing a DMA device. The iohgatp saves the PPN of the second-stage page table, the Guest Software Context ID (GSCID), and the Mode field used to select the second-stage address translation scheme. The tc contains many transformation control bits, most of which are not used in hvisor, and the valid bits need to be set to 1 for subsequent more advanced feature extensions. The structure of the device directory table entry is as follows:

Currently, hvisor only supports a single-level device directory table. The Lvl1DdtHw structure is defined to facilitate access to the device directory table entries. A single-level device directory table can support 64 DMA devices, occupying one physical page, as shown below:

The Iommu structure is defined as a higher-level abstraction of the IOMMU, where base is the base address of the IommuHw, i.e., the physical address of the IOMMU, which can be used to access the physical IOMMU, and ddt is the device directory table, which needs to be allocated physical pages during IOMMU initialization. Since it supports only a single-level device directory table, only one physical page is needed, as shown below:

The device directory table and translation page tables of the IOMMU are stored in memory and need to be allocated according to actual needs, i.e., the device directory table's memory needs to be allocated during new. In addition, adding device entries to the device directory table is a very important task because DMA devices perform DMA operations, the first step is to find the translation page tables and other information from the device directory table, and then the IOMMU performs the translation based on the page table-related information. The contents such as tc, iohgatp, etc., need to be filled in, as shown below:

Since hvisor supports RISC-V's IOMMU and Arm's SMMUv3, two interfaces for external calls, iommu_init and iommu_add_device, are encapsulated during implementation. These two functions have the same function names and parameters as the common call interface functions under the Arm architecture, as shown below: